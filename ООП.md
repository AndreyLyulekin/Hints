ООП

Разница между ООП и ФП
ООП все в классах и обьектах, Состояние хранится внутри объектов, все Изменения через методы есть наследование, инкапсуляция, полиморфизм лучше всего для моделирования сущностей
ФП это все в Функциях, использование чистых Функций (один и тот же вход → всегда один и тот же выход) самое нарушаемое это Иммутабельность (когда данные не должны менятся, а все через создание новых копий с изменениями) лучше всего для вычислений с большим потоком данных

**Модификаторы доступа для свойств и методов класса**
По умолчанию все поля и методы — public
public - Доступен из любого места: из экземпляра, из наследников, из внешнего кода
private	- Видно только внутри самого класса, Нельзя вызвать или получить или изменить извне и даже из наследника - те не позволяет другим частям кода случайно их изменять
protected - Похож на private, но доступен внутри наследников и скрыт из внешнего кода
+ Есть нюанс в тайпскрпте, ооочень редко используется #private одна из супер новых штук
Самая жесткая приватность - убирается на этапе рантайма
    
    Для чего:
Скрыть внутреннюю реализацию (те посути инкапсуляция)
Для контроля API класса — даем наружу только нужные методы
Защита данных от случайного изменения


**Концепции**:
● Инкапсуляция ^^^ (пример модификаторы доступа)
и скрытие деталей реализации от внешнего мира.
● Наследование Посути это иерархия классов от базового к  более конкретному, где один суперкласс/предок передает свои свойства/методы наследникам/подклассам
а наследованики могут переиспользовать код, определенный в суперклассе. Наследник может добавить свои собственные свойства и методы, а также изменить или расширить поведение унаследованных методов.
● Полиморфизм: возможность объектов наследников использовать методы базового класса, но предоставлять свою собственную реализацию этих методов
Пример энимал - сам саунд, кошечка, собачка
● Абстракция - создание методов в суперклассе через общий контракт для разных реализаций,
посути Описывает только суть, без деталей
Пример: 
abstract class Shape {
  abstract getArea(): number;
}

● Интерфейсы: это контракт: он определяет, что должен уметь объект,
но не говорит, как это реализовано - создаем шаблон для классов, определяя, какие методы должны быть реализованы классом.
● Агрегация: один объект содержит другой, но второй может существовать отдельно - при агрегации обьект содержит в себе другие методы как часть структуры
● Композиция: это создание сложных объектов путем объединения более простых объектов или компонентов.
(класс "Компьютер" может быть составлен из подклассов "Процессор", "Оперативная память" и тд
для создания модульных и гибких систем)

**Принципы**:
Вместе они делают код гибким, устойчивым и понятным

Solid
● Single respo-ty - Каждый класс/модуль должен быть ответственен только за одну логику/задачу.
Антипример: Класс который считает, делает фетч запрос и сохраняет что-то в файл это плохо
● Open/Closed Principle - можно добавить новое поведение,
но нельзя ломать существующее - Код должен быть открыт для расширения, но закрыт для модификации те через все полиморфизм
● Принцип подстановки Б.Л. 
Этот принцип про то, что подклассы могут использоваться везде, где используется суперкласс, при этом не нарушая корректность работы программы.
Иначе говоря — если B наследует A, то в любом месте, где ожидается A, можно безопасно использовать B
● Разделения интерфейса - Лучше несколько маленьких интерфейсов, чем один огромный
Интерфейсы должны быть разделены на более мелкие/специфичные, чтобы избежать избыточности.
● Инверсия зависимостей Модули верхних уровней не должны зависеть от модулей нижних уровней.
Оба уровня должны зависеть от абстракций, а абстракции не должны зависеть от деталей 
Если поменяем базу данных к примеру с SQL на монго не должно все сломаться в суперклассе

DRY (Don't Repeat Yourself), KISS (Keep It Simple, Stupid), YAGNI (You Ain't Gonna Need It)
Separation of Concerns - Разделяй логику по зонам ответственности
