Реактивность
При изменении данных, обновляется интерфейс, без явного

Разница между функциональными компонентами и классовыми компонентами
● Классовые
● ● Определяются как JavaScript-классы, которые наследуются от базового класса Component
● ● Используют методы жизненного цикла, такие как componentDidMount,componentDidUpdate, componentWillUnmount, componentDidCatch(((Когда в дочернем компоненте происходит ошибка, она пробрасывается вверх по иерархии компонентов, пока не встретит компонент с методом componentDidCatch)))
● ● Есть ErrorBoundary
● ● Дефолтно имеют состояние this.state this.setState
● ● Метод рендер

● Функциональные:
● ● Используются хуки для управления состоянием
● ● Более простые и в написании и чтении
● ● Не поддерживают состояние без хука useState
● ● Более производительные, так как отсутствует необходимость создания экземпляра класса.
● ● Возвращает jsx через ретерн, или null

Хуки
хуки в React — это API, предоставляемый React
● useState - возвращает кортеж, текущее состояние и колбэк для его изменения(реализовано на замыканиях, есть доступ к предыдущему значению)
● useRef - ссылка на обьект с одним свойством current для доступа к DOM элементу, не реактивно
● useEffect - аналог трех жизненных циклов в классовых компонентах (выполняется после отрисовки)
● useLayoutEffect - аналог componentDidMount(выполняет код, до отрисовки)- который блокирует интерфейс
https://www.youtube.com/watch?v=n_OtFAsh6aU&ab_channel=%D0%90%D0%B9%D0%A2%D0%B8%D0%A1%D0%B8%D0%BD%D1%8F%D0%BA
● useContext - получааем данные вне пропс дриллинга из контекста (createContext)
● useReducer - альтернативный способ управления состоянием в функциональных компонентах, для более сложного стейта к примеру в редакс
● useMemo - кэшируем результат выполнения функции
● useCallback - оборачивает функцию, для пердотвращения повторного создания функции или рендеринга, при передаче через пропс

forceUpdate
Полезно, когда данные, не связаные с состоянием или пропсами, были изменены и нужно обновить интерфейс в для отображения изменений.
const [, forceUpdate] = useState(0);
const handleClick = () => {
forceUpdate((prevState) => prevState + 1);
};
