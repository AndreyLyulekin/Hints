Реактивность
Каждый "вычисляемый" элемент подписывается на данные, от которых зависит.
Когда данные меняются — система пересчитывает
При изменении данных, обновляется интерфейс, без явного указания (VUE)

РЕАКТ НЕ РЕАКТИВЕН
Эмулирует реактивность
В Настоящей реактивности это все происходит автоматически и изменения вносятся точечно
В реакте же зависимости указываются явно/вручную в useEffect или при вызове SetState и перерендеривается весь компонент после диффинга в Virtual DOM

Файбер дерево - используется React для отслеживания и управления компонентами при рендеринге

Конкурентный режим - это 18+ реакт, когда приложение остается отзывчивым во время выполнения рендеринга. Когда React может приостановить рендеринг для обработки задач с высоким приоритетом, например при пользовательских клике.

Контекст для разных UI состояний
Redux для:
● данные о текущем пользователе
● список товаров в корзине
● истории состояния для будущего восстановления
● бизнес логику

Разница между функциональными компонентами и классовыми компонентами
Компонент — это функция или класс, который возвращает JSX
● Классовые
● ● Определяются как JavaScript-классы, которые наследуются от базового класса Component
● ● Используют методы жизненного цикла, такие как componentDidMount,componentDidUpdate, componentWillUnmount, componentDidCatch(((Когда в дочернем компоненте происходит ошибка, она пробрасывается вверх по иерархии компонентов, пока не встретит компонент с методом componentDidCatch)))
● ● Есть ErrorBoundary
● ● Дефолтно имеют состояние this.state this.setState
● ● Метод рендер

● Функциональные:
● ● Не поддерживают состояние без хука useState и для управления тоже используются хуки
● ● Более простые и в написании и чтении
● ● Более производительные, тк создания экземпляра класса относительно дорогостоящие операции
● ● Возвращает jsx через ретерн, или null

Хуки
хуки в React — это API, предоставляемый React
● useState - возвращает кортеж, текущее состояние и колбэк для его изменения(реализовано на замыканиях, есть доступ к предыдущему значению)
● useRef - ссылка на обьект с одним свойством current для доступа к DOM элементу, не псевдо-реактивно
● useEffect - асинхронный, аналог трех жизненных циклов в классовых компонентах (выполняется после отрисовки) 
● useLayoutEffect - синхронный, аналог componentDidMount(выполняет код, до отрисовки)- который блокирует интерфейс
https://www.youtube.com/watch?v=n_OtFAsh6aU&ab_channel=%D0%90%D0%B9%D0%A2%D0%B8%D0%A1%D0%B8%D0%BD%D1%8F%D0%BA
● useContext - получааем данные вне пропс дриллинга из контекста (createContext)
● useReducer - альтернативный способ управления состоянием в функциональных компонентах, для более сложного стейта к примеру в редакс
● useMemo - кэшируем результат выполнения функции
● useCallback - оборачивает функцию, для прердотвращения повторного создания функции или прердотвращения ререндеринга, при передаче через пропс, в дочерние компоненты которые обернуты в Memo 

+ MEMO
Принимает два аргумента:
- первый компонент, 
- второе своя функция сравнения пропсов, можно смотреть только на определенный набор, по дефолту сравнивает поверхностно, что-бы сравнивать глубоко, надо смотреть делать свое решение, рекурсивно смотреть на ключи/значения

forceUpdate
Полезно, когда данные, не связаные с состоянием или пропсами, были изменены и нужно обновить интерфейс в для отображения изменений.
const [, forceUpdate] = useState(0);
const handleClick = () => {
forceUpdate((prevState) => prevState + 1);
};

В 18 реакте батчинг появился
Когде в каком-то месте мы вызываем к примеру один и тот-же сет стейт несколько раз, то раньше это было несколько рендеров, после батчинга, это все будет один ререндер

реакт файбер
почему компонент может быть перерендерен:
изменение ключей пропсов, родителя, контекста, вызов сетстейт, форс апдейт, 

Что такое jsx под капотом
обьект + реакт крейт компонент + 

react portal

Полиморф компонент???????????????????????????????????????????????????????
