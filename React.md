Реактивность
Каждый "вычисляемый" элемент подписывается на данные, от которых зависит.
Когда данные меняются — система пересчитывает
При изменении данных, обновляется интерфейс, без явного указания

РЕАКТ НЕ РЕАКТИВЕН
Эмулирует реактивность
В Настоящей реактивности это все происходит автоматически и изменения вносятся точечно
В реакте же зависимости указываются явно/вручную в useEffect или при вызове SetState и перерендеривается весь компонент после диффинг в Virtual DOM

Файбер дерево - используется React для отслеживания и управления компонентами при рендеринге

Конкурентный режим - это 18+ реакт, когда приложение остается отзывчивым во время выполнения рендеринга. Когда React может приостановить рендеринг для обработки задач с высоким приоритетом, например при пользовательских клике.

Контекст для разных UI состояний
Redux для:
● данные о текущем пользователе
● список товаров в корзине
● истории состояния для будущего восстановления
● бизнес логику

Разница между функциональными компонентами и классовыми компонентами
Компонент — это функция или класс, который возвращает JSX
● Классовые
● ● Определяются как JavaScript-классы, которые наследуются от базового класса Component
● ● Используют методы жизненного цикла, такие как componentDidMount,componentDidUpdate, componentWillUnmount, componentDidCatch(((Когда в дочернем компоненте происходит ошибка, она пробрасывается вверх по иерархии компонентов, пока не встретит компонент с методом componentDidCatch)))
● ● Есть ErrorBoundary
● ● Дефолтно имеют состояние this.state this.setState
● ● Метод рендер

● Функциональные:
● ● Используются хуки для управления состоянием
● ● Более простые и в написании и чтении
● ● Не поддерживают состояние без хука useState
● ● Более производительные, так как отсутствует необходимость создания экземпляра класса
● ● Возвращает jsx через ретерн, или null

Хуки
хуки в React — это API, предоставляемый React
● useState - возвращает кортеж, текущее состояние и колбэк для его изменения(реализовано на замыканиях, есть доступ к предыдущему значению)
● useRef - ссылка на обьект с одним свойством current для доступа к DOM элементу, не реактивно
● useEffect - аналог трех жизненных циклов в классовых компонентах (выполняется после отрисовки)
● useLayoutEffect - аналог componentDidMount(выполняет код, до отрисовки)- который блокирует интерфейс
https://www.youtube.com/watch?v=n_OtFAsh6aU&ab_channel=%D0%90%D0%B9%D0%A2%D0%B8%D0%A1%D0%B8%D0%BD%D1%8F%D0%BA
● useContext - получааем данные вне пропс дриллинга из контекста (createContext)
● useReducer - альтернативный способ управления состоянием в функциональных компонентах, для более сложного стейта к примеру в редакс
● useMemo - кэшируем результат выполнения функции
● useCallback - оборачивает функцию, для пердотвращения повторного создания функции или рендеринга, при передаче через пропс

forceUpdate
Полезно, когда данные, не связаные с состоянием или пропсами, были изменены и нужно обновить интерфейс в для отображения изменений.
const [, forceUpdate] = useState(0);
const handleClick = () => {
forceUpdate((prevState) => prevState + 1);
};

Полиморф компонент???????????????????????????????????????????????????????
