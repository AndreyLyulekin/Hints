<a name="top"></a>
[Debounce](#Debounce)  
[Throttle](#Throttle)  
[Двойной указатель](#findTwoSum)  
[Палиндром](#palindrome)  
[Поиск дубликатов](#searhDuplicate)  
[Словарик + Анаграм](#anagram)  
[Обьединение интервалов](#mergeInterval)  
[Сортировка пузырьком](#bubblesort)  
[Правильная последовательность скобок](#brackets)  
[Первый уникальный символ](#firstUnique)  
[Пересечение двух массивов](#intersection)  
[fizzBuzz](#fizzBuzz)  
[Массив с наибольшими значениями](#largestOfArr)  
[Алгоритм бинарного поиска](#binarySearch)

// Оценка сложности по скорости/операциям  
// O(1) константная - не важно сколько данных на входе ПРИМЕР: получить последний эл массива  
// O(n) линейная - 10 вход данных = 10 операций, просто 1 цикл  
// O(log n) логарифмическая - 100 вход данных - 7 операций || 10*000 = 14 (бинарный поиск)  
// O(n"2) - квадратичная - 10_000 = 100_000_000 || 10 = 100, цикл в цикле  
// O(n"3) - кубическая - 10_000 = 1_000_000_000_000 || 10 = 1_000, три вложенных цикла  
// O(2"n) - экспонинциальная - дохера  
// O(n!) - факториал 3 * 2 _ 1 = 6 || 5 _ 4 _ 3 _ 2 \_ 1 = 120

// Оценка сложности по памяти  
// O(1) константная - не важно сколько данных на входе - хранение результата  
// O(n) линейная - 10 вход данных = 10 операций - копирование массива  
// O(N^2) - квадратичная - если используются множество структур данных

//Вопросы,  
// какие могут быть входящие данные и какие крайние кейсы?  
// какие требования по памяти или скорости?

//циклы  
// for of - итерирование по значению  
// for in - для обьектов, итерирование по ключам (у массива по индексам, что-бы по ключам arr[item])

// **Debounce**  
<a name="Debounce"></a>
// для того, что-бы функция была вызвана только после  
// определенной паузы. Предыдущие вызовы будут отменены, и функция будет вызвана только один раз.  
const debounce = () => {  
let timerID;  
return function () {  
clearTimeout(timerID);  
timerID = setTimeout(() => {  
//logic  
}, 1000);  
};  
};

[Наверх](#top)

// **Throttle**  
<a name="Throttle"></a>  
// что-бы функция вызывалась не чаще,  
// чем в какой-то интервал времени.  
function throttle(func, delay) {  
let timeoutId;

return function () {  
if (!timeoutId) {  
// вызываем функцию сразу  
func.apply(this, arguments);

      // задержка перед следующим вызовом
      timeoutId = setTimeout(() => {
        timeoutId = undefined;
      }, delay);
    }

};  
}

[Наверх](#top)

//
//
//
// **Двойной указатель**  
<a name="findTwoSum"></a>
//
//
//
// линейная сложность O(n)  
function findTwoSum(arr, target) {  
const result = [];  
//если результатов больше одного

let left = 0;  
let right = arr.length - 1;

while (left < right) {  
const sum = arr[left] + arr[right];

    if (sum === target) {
      result.push([arr[left], arr[right]]);
      right--;
      left++;
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }

}  
return result;  
}  
[Наверх](#top)

//
//
//
// **Палиндром**  
<a name="palindrome"></a>
//
//
//

// ПРОСТОЙ СПОСОБ - function palindrome (str)  
// string = string.toLowerCase().split('').join('') // убрать все символы .replace(/[^a-zа-я0-9]/g, '');  
// return string === string.split('').reverse().join('');

const str1 = '12321';  
const str2 = '123321';  
const str3 = '123';

function isPalindrome(string) {  
let isPalindrome = false;

let left = 0;  
let right = string.length - 1;

while (left <= right) {  
if (string[left] === string[right]) {  
isPalindrome = true;  
} else {  
break;  
}  
right--;  
left++;  
}  
return isPalindrome;  
}

console.log(isPalindrome(str1));
[Наверх](#top)

// **внутренний палиндром**  
// по памяти O(1) - константная

let innerPolindrome = (str) => {  
let start = 0;  
let end = 0;

for (let i = 0; i < str.length; i++) {  
let len1 = expand(str, i, i);  
let len2 = expand(str, i, i + 1);

    let length = Math.max(len1, len2);

    if (length > end - start) {
      start = Math.ceil(i - (length - 1) / 2);
      end = Math.floor(i + length / 2);
    }

}

function expand(str, left, right) {  
while (left >= 0 && right < str.length && str[left] === str[right]) {  
left--;  
right++;  
}  
return right - left - 1;  
}

return str.substring(start, end + 1);  
};

console.log(innerPolindrome('babad'));  
console.log(innerPolindrome('cbbd'));  
console.log(innerPolindrome('mississippi'));  
console.log(innerPolindrome('ac'));

//
//
//
// **поиск дубликатов**  
<a name="searhDuplicate"></a>
//
//
//

var containsDuplicate = function (nums) {  
const newNums = Array.from(new Set(nums));  
return nums.length === newNums.length ? false : true;  
};

[Наверх](#top)

//
//
//
// **создаем СЛОВАРИК + АНАГРАМ**  
<a name="anagram"></a>
//
//
//

function buildDictionary(str) {  
let dictionary = {};

for (let i = 0; i < str.length; i++) {  
let letter = str[i];

    if (dictionary[letter]) {
      dictionary[letter]++;
    } else {
      dictionary[letter] = 1;
    }

}  
return dictionary;  
}

//СЛОВАРЬ ЧЕРЕЗ REDUCE (на входе массив)  
let dictionary = nums1.reduce((acc, item) => {  
acc[item] = acc[item] ? acc[item] + 1 : 1;

return acc;  
}, {});

[Наверх](#top)

//сам АНАГРАМ - одни и теже буквы для разных слов  
let s = 'anagram';  
let t = 'naGaram';

let isAnagram = function (s, t) {  
if (s.length != t.length) return false;

s = s.toLowerCase();  
t = t.toLowerCase();

let sDictionary = buildDictionary(s);  
let tDictionary = buildDictionary(t);

for (let letter in sDictionary) {  
if (sDictionary[letter] != tDictionary[letter]) {  
return false;  
}  
}

return true;  
};

// ИЛИ В ОДНУ СТРОКУ

let isAnagram2 = (s, t) => [...s.toLowerCase()].sort().toString() === [...t.toLowerCase()].sort().toString();

[Наверх](#top)
//
//
//
// **обьединение интервалов**  
<a name="mergeInterval"></a>
//O(n log n) по времени  
//O(log n) по памяти из-за сортировке, если сорт в новый arr то O(n)  
//
//
//

const intervals = [  
[11, 12],  
[2, 3],  
[5, 7],  
[1, 4],  
[8, 10],  
[6, 8],  
];

const mergeInterval = (arr) => {  
if (arr.length < 2) {  
return arr;  
}

arr.sort((a, b) => a[0] - b[0]);

let result = [arr[0]];

for (let interval of arr) {  
//недавний  
let recent = result[result.length - 1];

    if (recent[1] >= interval[0]) {
      recent[1] = Math.max(recent[1], interval[1]);
    } else {
      result.push(interval);
    }

}

return result;  
};

console.log(mergeInterval(intervals));

[Наверх](#top)

//
//
//  
//**Сортировка пузырьком**  
<a name="bubblesort"></a>
//смысл сортировки пузырьком, за каждый проход по массиву, мы самый большой элемент ставим в конец  
//
//
//

function bubble(arr) {  
for (let i = 0; i < arr.length - 1; i++) {  
for (let j = i + 1; j < arr.length; j++) {  
if (arr[i] > arr[j]) {  
const temp = arr[i];  
arr[i] = arr[j];  
arr[j] = temp;  
}  
}  
}  
console.log(arr);  
}

bubble(arr);

[Наверх](#top)

//
//
//
//**Правильная последовательность скобок**  
<a name="brackets"></a>
//решаем через стэк, по памяти и скорости O(n) - линейная  
//
//
//

let s1 = '()';  
let s2 = '()[]{}';  
let s3 = '(]';  
let s4 = '(])';

function isValid(str) {  
//edge кейс, сразу вернем значение если символов не кратно двум  
if (str.length % 2 != 0) return false;

//тут нужен стэк куда кладем открывающиеся скобки  
let stack = [];  
//некий словарик с ключем открывающим и значением закрывающей скобки  
let brackets = {  
')': '(',  
'}': '{',  
']': '[',  
};

//тут делаем цикл идем по каждой скобке  
for (let i = 0; i < str.length; i++) {  
const current = str[i];

    //нужна функция где мы будем проверять является ли скобка закрывающей и !!! ДОСТАТЬ ИЗ ЦИКЛА
    function helperClosedBracket(char) {
      return [')', ']', '}'].indexOf(char) > -1;
    }

    //если current это закрывающаяся скобка
    if (helperClosedBracket(current)) {
      //проверяем последовательность скобок
      if (brackets[current] != stack.pop()) return false;
    } else {
      //если current не закрывающаяся скобка
      stack.push(current);
    }

}
//После цикла, проверяем, остались ли символы в стеке  
return stack.length === 0;  
}
[Наверх](#top)

//
//
//
// **Shuffle массива**  
<a name="shuffle"></a>
// O(n) - по скорости, O(1) - по памяти  
// Алгоритм Фишера-Йетса  
//
//
//

let shuffle = (arr) => {  
//с конца массива будем менять числа местами с рандомным индексом  
for (let i = arr.length - 1; i > 0; i--) {  
let temp = arr[i];  
let rnd = Math.floor(Math.random() \* arr.length);

    arr[i] = arr[rnd];
    arr[rnd] = temp;

}  
return arr;  
};

[Наверх](#top)

//
//
//
// **ПЕРВЫЙ УНИКАЛЬНЫЙ СИМВОЛ**  
<a name="firstUnique"></a>
// O(n) - по скорости, O(1) - по памяти  
//
//
//

let firstUnique = (str) => {  
//вернем -1 если нет уникальной буквы  
let result = -1;

//делаем словарик  
const dictionary = buildDictionary(str);

for (let [letter, count] of Object.entries(dictionary)) {  
if (count === 1) {  
result = letter;  
break;  
}  
}

return result;  
};

[Наверх](#top)

//
//
//
// **ПЕРЕСЕЧЕНИЕ ДВУх Массивов**  
<a name="intersection"></a>
//
//
//

const intersection = (arr1, arr2) => {  
let result = [];

let dictionary = arr1.reduce((acc, item) => {  
acc[item] = acc[item] ? acc[item] + 1 : 1;

    return acc;

}, {});

for (let i = 0; i < arr2.length; i++) {  
const current = arr2[i];  
let count = dictionary[current];

    if (count && count > 0) {
      result.push(current);
      dictionary[current] -= 1;
    }

}

return result;  
};

[Наверх](#top)

//
//
//
// **fizzBuzz**  
<a name="fizzBuzz"></a>
//
//
//
let input = 22;

let fizzBuzzFunc = (num) => {  
for (let i = 1; i <= num; i++) {  
//в первую очередь ставим fizzbuzz тк если иф тут сработает, то дальше он не пойдет  
if (i % 3 === 0 && i % 5 === 0) {  
console.log('fizzBuzz');  
} else if (i % 3 === 0) {  
console.log('fizz');  
} else if (i % 5 === 0) {  
console.log('buzz');  
} else {  
console.log(i);  
}  
}  
};

[Наверх](#top)

//
//
//
// **АЛГОРИТМ БИНАРНОГО ПОИСКА - после сортировки**  
<a name="binarySearch"></a>
// Сложность O(log n)  
//
//
//
let array = [-1, 0, 3, 5, 7, 9, 12];

let search = (arr, target) => {  
//три указателя  
let left = 0;  
let right = arr.length - 1;  
//будет переопределяться  
let mid;

//итерируемся пока левая граница меньше или равна правой  
while (left <= right) {  
mid = Math.round((right - left) / 2 + left);

    if (target === arr[mid]) {
      //если попали сразу или нашли в итоге
      return mid;
    } else if (target < arr[mid]) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }

}  
return -1;  
};

[Наверх](#top)

//
//
//
// **Массив наибольших значений вложенного массива**  
<a name="largestOfArr"></a>
//
//
//
// [1,2,3,4]  
// [5,18,0,12]  
// [3,5,12,5]  
// [28,9,2,34]

// Should return => [4,18,12,34]

function largestOfFour(arr) {  
let arrayOfMaxValues = [];  
for (let i = 0; i < arr.length; i++) {  
let subArr = arr[i];  
let maxSubArrVal = 0;  
for (let j = 0; j < subArr.length; j++) {  
let currentValue = subArr[j];  
if (currentValue > maxSubArrVal) {  
maxSubArrVal = currentValue;  
}
}
arrayOfMaxValues.push(maxSubArrVal);  
}
return arrayOfMaxValues;  
}

[Наверх](#top)

//
//
//
// **Самое длинное слово**  
// Вернуть длину самого длинного слова в проверяемом предложении.  
//
//
//

function findLongestWordLength(str) {  
let maxVal = 0;

const wordArr = str.split(' ');

for (let i = 0; i < wordArr.length; i++) {  
let word = wordArr[i];  
if (word.length > maxVal) {  
maxVal = word.length;  
}  
}  
return maxVal;  
}

[Наверх](#top)

//
//
//
//**при первом вызове вернуть n, при последующем вызове n+1**  
//
//
//

[Наверх](#top)

let createCounter = function (start) {  
let count = start;  
return function () {  
return count++;  
};
};
const counter = createCounter(10);  
console.log(counter()); // 10  
console.log(counter()); // 11  
console.log(counter()); // 12

//
//
//
// **isIsomorph - буква одной строки должна быть равна букве другой строки**  
//
//
//

let isIsomorphic = (s, t) => {  
if (s.length != t.length) return false;  
if (s.length === 0 || t.length === 0) return false;  
if (new Set(s).size != new Set(t).size) return false;

let result;  
let dictionary = {};

for (let i = 0; i < s.length; i++) {  
if (dictionary[s[i]]) {  
if (dictionary[s[i]] != t[i]) {  
result = false;  
break;  
}  
} else {  
dictionary[s[i]] = t[i];  
result = true;  
}  
}

return result;  
};

console.log(isIsomorphic((s = 'badc'), (t = 'baba')));

[Наверх](#top)

//
//
//
// **убрать из массива все что кратно трем**  
//
//
//

let someFunc = (arr) => {  
for (let i = arr.length - 1; i >= 0; i--) {  
if (arr[i] % 3 === 0) arr.splice(i, 1);  
}

return arr;  
};

[Наверх](#top)

//
//
//
// **Каррирование**  
//
//
//

function curry(f) {  
 // curry(f) выполняет каррирование  
 return function(a) {  
 return function(b) {  
 return f(a, b);  
 };  
 };  
}

// использование  
function sum(a, b) {  
 return a + b;  
}

let curriedSum = curry(sum);

console.log(curriedSum(1)(2)); // 3

[Наверх](#top)

**Получить свойство обьекта по пути**

function getValueByPath(object, path) {  
const parts = path.split(".");  
console.log(parts);  
let current = object;

for (let part of parts) {  
if (current[part] === undefined) {  
return undefined; // Если свойство не найдено, возвращаем undefined  
}  
current = current[part];  
}  
return current;  
}

console.log(  
getValueByPath(  
{  
items: [{ child: { colors: [{ name: "red" }, { name: "green" }] } }],  
},  
"items.0.child.colors.1.name"  
)  
);

[Наверх](#top)

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// **Почему цикл for быстрее чем forEach**
//

// Создаем массив с миллионом элементов, заполненных случайными числами от 0 до 999
const array = new Array(1000000).fill().map(() => Math.floor(Math.random() \* 1000));

// Замеряем время выполнения для цикла for
console.time('for loop');
for (let i = 0; i < array.length; i++) {
const element = array[i];
// В данном примере просто проходим по массиву, ничего не делая
}
console.timeEnd('for loop');

// Замеряем время выполнения для метода forEach
console.time('forEach');
array.forEach((element) => {
// В данном примере просто проходим по массиву, ничего не делая
});
console.timeEnd('forEach');

function reverseString(str) {
let reversedString = '';

/_ Проходим по каждому символу в аргументе str
Чтобы развернуть строку, мы присваиваем переменной i значение str.length
Добавляем по очереди каждый символ строки str, начиная с конца, в новую строку.
_/
for (let i = str.length; i > 0; i--) {
reversedString += str.substring(i, i - 1);
}
return reversedString;
}

console.log(reverseString('Hello world!'));
//ИЛИ
function reverseString(str) {
return str.split('').reverse().join('');
}

[Наверх](#top)
