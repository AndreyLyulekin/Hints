REST API (Representational State Transfer Application Programming Interface) - архитектурный стиль клиент-серверного взаимодействия, посредством HTTP-протокола.

Основные принципы REST API:
Клиент-серверная архитектура: сервер дает ресурсы, а клиенты отправляют запросы
Без состояния (stateless):
Кэширование: сервер может указывать клиенту, можно ли кэшировать ответы на запросы.
Семантика методов стартовой строки

Docker
Это платформа, которая позволяет упаковывать и запускать приложения в изолированных контейнерах. Docker упрощает развертывание и масштабирование приложений.

JSON (JavaScript Object Notation)
Это формат обмена данными, основанный на синтаксисе JavaScript.

var - функциональная область видимости, может быть обьявлена повторно
let, const - появились после ES6 (ES-2015)
let, const - блочная область видимости {}
var, let - могут быть обьявлены до записи значения, и могут быть переопределены
const - не может быть обьявлена до записи значения и соответственно не может быть переопределена, свойства обьектов обьявленных через конст можно изменить
let, const удаляется из памяти после окончательного использования, в отличии от var, становится не инициализированной
Неинициализированная переменная - объявляется с присвоением памяти, но без присвоения значения
При хойстинге, (всплытие в глобальный обьект виндоу, перед выполнением кода) var инициализируется - присваивается значение и тип undefined, let и const остаются неинициализированными
Т.е. у var идёт незначительная нагрузка при построении синтаксического дерева
Нагрузка в том, что при инициализации var, задается значение и тип по умолчанию, затем меняется, когда дело доходит до присвоения значения. Это двойная работа, чего нет у let и const

Hoisting
переменные и функции обьявленные через Function Declaration поднимаются в начало области видимости, присваивание остается на прежнем месте
Strikt mode - переменные не могут быть использованы до их фактического объявлени

Хэширование (Hashing)
Это процесс преобразования данных фиксированной длины в хэш-значение фиксированного размера. Хэширование используется для уникальной идентификации данных и быстрого поиска.

Как можно скопировать/клонировать объект?
● spread - Глубокое копирование происходит только для первого уровня свойств, далее по ссылке
● Object.assign() - аналог spread
● JSON.parse(JSON.stringify(arr)) - копирует глубоко, но без методов, хорош для мал операций
● Object.create(originalObj) - неглубоко, берет существующий объект как прототип, копирует все свойства и методы

this
Грубо говоря, this — это ссылка на объект, к свойствам которого можно получить
доступ внутри вызова функции. this — контекст выполнения.

stopImmediatePropagation() – для предотвращения вызова других обработчиков
событий на текущем элементе

Что не переживает localStorage? – Очистку кэша

Методы объектов:
● Object.keys(obj) – возвращает массив строк, представляющих перечисляемые
свойства объекта.
● Object.values(obj) – возвращает массив значений
● Object.entries(obj) – возвращает массив пар [ключ, значение]
● Object.assign(target, ...sources) – копирует значения всех перечисляемых
свойств из одного или нескольких исходных объектов в целевой объект.
● Object.create(proto, [propertiesObject]) – создает новый объект с указанным
прототипом и опциональными дополнительными свойствами.
● obj.hasOwnProperty(prop) – возвращает логическое значение, указывающее присутствует ли ключ

Чем bind отличается от call?
● Метод bind создает новую функцию, устанавливает указанный контекст
выполнения для этой функции и возвращает эту функцию, не вызывая её.
● Метод call вызывает функцию с указанным контекстом выполнения и принимает аргументы в виде списка.
● Метод apply также вызывает функцию с указанным контекстом выполнения, принимает аргументы в виде массива.

Разница между async и defer у тега script?
● async скрипты могут быть выполнены до завершения загрузки
HTML-документа, если несколько то они не мешают друг другу
● defer скрипты будут выполнены только после завершения загрузки
HTML-документа. если несколько то очередь
● Без указания атрибута: Скрипт загружается и выполняется сразу же, блокируя загрузку и рендеринг страницы,
пока он не будет полностью загружен и выполнен.

Иммутабельность в программировании означает, что данные не могут быть изменены после их создания.
Вместо этого, при необходимости изменить данные, создается новая копия с нужными изменениями.

Архитектура браузера:
● User Interface (часть с которой мы взаимодействуем, где вводим юрл кнопки вперед/назад)
● Browser Engine (соединительная часть между UI и механизмом рендеринга)
● Движок рендера (благодаря которому мы получаем страницы webkit-chrome geka-firefox
задача - обработка кода, html, css, js. Строит дом дерева css дерева, определяется расположение элементов)
● Networking (история, обработка http, обмен пакетами)
● js интерпретатор (v8 движок обработчик js на node.js и в браузере, работает с памятью/сборкой мусора
компиляция js в машинный код, и отвечает за call stack, работа с кэшем, firefox - spidermonkey)
● data persistence (хранилище для браузера, local-session storage и тд)

Архитектура движка рендера(webkit):
на вход приходить html, css, он их парсит
из штмл получаем дом дерево, из css получаем правила стилей
потом строится дерево рендера
потом стадии layout pending composite

Стадии рендера
● строится dom tree (Document Object Model)
● cssom
● render tree ->
● ● Калькуляция стилей - применение селекторОВ стилей к элементам
● ● layout tree - составление макета, расстановка элементов
● ● paint - рисует из чертежа пиксели
● ● compositing tree - дерево слоев, layer tree, z-index
(при нажатии на кнопку и открытии попапа/изменении размера окна/контента все по кругу)

Event Loop (отвечает за очередь задач) предоставляется средой выполнения (браузер, nodejs)
● call stack (lifo) - (предоставляет движок) небесконечный, можно переполнить
● web API (связывает коллстэк и задачи, это таймауты обработка слушателей/событий )
● очередь задач (предоставляет event loop)
● макротаски - очередь событий (fetch, timer, клик, загрузка изображ, ввод инпут, рендер)
● микротаски - очередь задач (промис, queueMicrotask, mutaionObserver (слежение за дом нодами, какие добавлены/убраны))

Паттерны

Антипатерны
● God-Object (классы/модули/компоненты решают сразу всё, в нарушение солид) тут нет высокой связаннности и слабой зацепленности

Таблица приведения (Type coercion table)
● нестрогое == и != автоматически перед сравнением
● явное делает разработчик, функции Number(), String() и Boolean()
