**Docker**
Это платформа, которая позволяет упаковывать и запускать приложения в изолированных контейнерах. Docker упрощает развертывание и масштабирование приложений.

**PROMISE**
Создан что-бы убрать проблему колбэк хэла
Это микротаска, под капотом работающая через microtaskQueue()

Методы:
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

**Деструктуризация**
это когда можно извлекать данные из массивов или обьектов и сразу назначать на переменные

1.  // Деструктуризация массива  
     const numbers = [1, 2, 3, 4, 5];

const [a, b, ...rest] = numbers;

console.log(a); // Вывод: 1
console.log(b); // Вывод: 2
console.log(rest); // Вывод: [3, 4, 5]

2.  // Деструктуризация объекта  
     const person = {
    name: "Alice",
    age: 30,
    city: "New York"
    };

// Деструктуризация объекта с оператором spread
const { name, ...details } = person;

console.log(name); // Вывод: "Alice"
console.log(details); // Вывод: { age: 30, city: "New York" }

**JSON (JavaScript Object Notation)**
Это формат обмена данными, основанный на синтаксисе JavaScript.

var - функциональная область видимости, может быть обьявлена повторно
let, const - появились после ES6 (ES-2015)
let, const - блочная область видимости {}
var, let - могут быть обьявлены до записи значения, и могут быть переопределены
const - не может быть обьявлена до записи значения и соответственно не может быть переопределена, свойства обьектов обьявленных через конст можно изменить
let, const удаляется из памяти после окончательного использования, в отличии от var, становится не инициализированной
Неинициализированная переменная - объявляется с присвоением памяти, но без присвоения значения
При хойстинге, (всплытие в глобальный обьект виндоу, перед выполнением кода) var инициализируется - присваивается значение и тип undefined, let и const остаются неинициализированными
Т.е. у var идёт незначительная нагрузка при построении синтаксического дерева
Нагрузка в том, что при инициализации var, задается значение и тип по умолчанию, затем меняется, когда дело доходит до присвоения значения. Это двойная работа, чего нет у let и const

**Hoisting**
переменные и функции обьявленные через Function Declaration поднимаются в начало области видимости, присваивание остается на прежнем месте
Strikt mode - переменные не могут быть использованы до их фактического объявлени

**ФУНКЦИИ**
Функция высшего порядка, принимает функцию, отдает функцию

Функция первого класса - чистая функция

Function Declaration
Хойстится, Функция конструктор, через new можно создавать обьекты,
имеет this && arguments,
не может быть использована для создания методов обьекта из-за хойстинга (поднимается в начало контекста выполнения, и функция не будет привязана как метод к обьекту)

Function Expression
const greet = function sayHello() {console.log("Привет!");
};
Не хойстится, есть arguments && имеет this, может быть анонимной
может быть использована для создания методов обьекта
после ES6 как метод можно писать без function

Анонимные функции как часть Function Expression
Чаще всего используются как колбэки, или IIFE

Arrow functions ES6
const greet = () => return "Привет!"
Сохраняют контекст this родительской области видимости
Не имеют собственного объекта arguments

**СТРУКТУРЫ ДАННЫХ:**

1. new Map:
   Очень схож с обьектом, отличие в том, есть свои методы, в качестве ключей могут быть любые типы данных
   Есть метод get(ключ), set('ключ', значение), delete(ключ) - возвращает true/false, clear, size

2. new Set:
   Set представляет собой коллекцию уникальных значений, где каждое значение может быть добавлено только один раз. Set также поддерживает методы для добавления, удаления и проверки наличия элементов, а также итерирования по ним. Элементы в Set сохраняются в том порядке, в каком они были добавлены.
   теже методы, + has, values/keys - вернет тоже самое

3. new WeakMap:
   разновидность Map, где ключи объекты, а значения могут быть любыми.
   Один из главных отличий WeakMap от Map заключается в том, что WeakMap не предотвращает удаление ключей из памяти, если они больше не используются в программе.

4. new WeakSet:
   WeakSet является специальной разновидностью Set, где элементы должны быть объектами. Как и в случае с WeakMap, WeakSet не предотвращает удаление элементов из памяти, если они больше не используются.

**Хэширование (Hashing)**
Это процесс преобразования данных фиксированной длины в хэш-значение фиксированного размера. Хэширование используется для уникальной идентификации данных и быстрого поиска.

Что не переживает localStorage? – Очистку кэша

**Как можно скопировать/клонировать объект?**
● spread - Глубокое копирование происходит только для первого уровня свойств, далее по ссылке
● Object.assign() - аналог spread
● JSON.parse(JSON.stringify(arr)) - копирует глубоко, но без методов, хорош для мал операций
● Object.create(originalObj) - неглубоко, берет существующий объект как прототип, копирует все свойства и методы

this
Грубо говоря, this — это ссылка на объект, к свойствам которого можно получить
доступ внутри вызова функции. this — контекст выполнения.

**Чем BIND отличается от CALL, APPLY**
● Метод bind создает новую функцию, устанавливает указанный контекст
выполнения для этой функции и возвращает эту функцию, не вызывая её.
● Метод call вызывает функцию с указанным контекстом выполнения и принимает аргументы в виде списка.
● Метод apply также вызывает функцию с указанным контекстом выполнения, принимает аргументы в виде массива.

**Методы объектов:**
● Object.keys(obj) – возвращает массив строк, представляющих перечисляемые
свойства объекта.
● Object.values(obj) – возвращает массив значений
● Object.entries(obj) – возвращает массив пар [ключ, значение]
● Object.fromEntries(arr) - возвращает обьект из пар [ключ, значение]
● Object.assign(target, ...sources) – копирует значения всех перечисляемых
свойств из одного или нескольких исходных объектов в целевой объект.
● Object.create(proto, [propertiesObject]) – создает новый объект с указанным
прототипом и опциональными дополнительными свойствами.
● obj.hasOwnProperty(prop) – возвращает логическое значение, указывающее присутствует ли ключ

**Разница между ASYNC и DEFER у тега SCRIPT?**
● async скрипты могут быть выполнены до завершения загрузки
HTML-документа, если несколько то они не мешают друг другу
● defer скрипты будут выполнены только после завершения загрузки
HTML-документа. если несколько то очередь
● Без указания атрибута: Скрипт загружается и выполняется сразу же, блокируя загрузку и рендеринг страницы,
пока он не будет полностью загружен и выполнен.

ИММУТАБЕЛЬНОСТЬ в программировании означает, что данные не могут быть изменены после их создания.
Вместо этого, при необходимости изменить данные, создается новая копия с нужными изменениями.

Абстрактный класс, который не инициализируется(через "new ") используется в качестве прототипа, для наслдования, определяет структуру и методы

**EVENT LOOP** (отвечает за очередь задач) предоставляется средой выполнения (браузер, nodejs)
● call stack (lifo) - (предоставляет движок) небесконечный, можно переполнить
● web API (связывает коллстэк и задачи, это таймауты обработка слушателей/событий )
● очередь задач (предоставляет event loop)
● макротаски - очередь событий (fetch, timer, клик, загрузка изображ, ввод инпут, рендер)
● микротаски - очередь задач (промис, queueMicrotask, mutaionObserver (слежение за дом нодами, какие добавлены/убраны))

**ПАТТЕРНЫ**
● Singleton (Одиночка): что у класса будет только один экземпляр. Он полезен, когда нужно гарантировать, что объект создается только один раз и глобально доступен.
● Decorator (Декоратор): Этот паттерн позволяет динамически добавлять новую функциональность или поведение к существующему объекту.
● Observer (Наблюдатель): Этот паттерн позволяет объектам следить и реагировать на изменения состояния других объектов.
● Factory (Фабрика): Этот паттерн предоставляет способ создавать экземпляры классов определенного типа.

**АНТИПАТТЕРНЫ**
● God-Object (классы/модули/компоненты решают сразу всё, в нарушение солид) тут нет высокой связаннности и слабой зацепленности
● Golden Hammer (Золотой молоток): Этот антипаттерн описывает ситуацию, когда разработчики используют один и тот же подход или инструмент в разных ситуациях, даже если это не является самым эффективным или подходящим решением.
● Spaghetti Code (Лапшевый код): Этот антипаттерн описывает код, который сложно понять и поддерживать из-за запутанной логики и неясного потока выполнения.
● Dead Code (Мертвый код): Этот антипаттерн описывает код, который больше не используется в программе, но все еще присутствует в базе кода.

**Таблица приведения (Type coercion table)**
● нестрогое == и != автоматически перед сравнением
● явное делает разработчик, функции Number(), String() и Boolean()

**Погружение, захват и всплытие событий – это событийная модель**
Погружение идет от самого верхнего элемента в DOM собирая обработчики, и начиная с целевого элемента (захват) начинается всплытие и вызов обработчиков

stopImmediatePropagation() – для предотвращения вызова других обработчиков
событий на текущем элементе

Полифилл - код || метод || функциональность которая отсутствует в старых версиях браузеров, и мы пишем новый код добавляя метод, к примеру Array.prototype.includes()

Лексическое окружение
Promise
ЗАДАЧИ РЕКУРСИЯ
Код сплиттинг
