Docker
Это платформа, которая позволяет упаковывать и запускать приложения в изолированных контейнерах. Docker упрощает развертывание и масштабирование приложений.

JSON (JavaScript Object Notation)
Это формат обмена данными, основанный на синтаксисе JavaScript.

var - функциональная область видимости, может быть обьявлена повторно
let, const - появились после ES6 (ES-2015)
let, const - блочная область видимости {}
var, let - могут быть обьявлены до записи значения, и могут быть переопределены
const - не может быть обьявлена до записи значения и соответственно не может быть переопределена, свойства обьектов обьявленных через конст можно изменить
let, const удаляется из памяти после окончательного использования, в отличии от var, становится не инициализированной
Неинициализированная переменная - объявляется с присвоением памяти, но без присвоения значения
При хойстинге, (всплытие в глобальный обьект виндоу, перед выполнением кода) var инициализируется - присваивается значение и тип undefined, let и const остаются неинициализированными
Т.е. у var идёт незначительная нагрузка при построении синтаксического дерева
Нагрузка в том, что при инициализации var, задается значение и тип по умолчанию, затем меняется, когда дело доходит до присвоения значения. Это двойная работа, чего нет у let и const

Hoisting
переменные и функции обьявленные через Function Declaration поднимаются в начало области видимости, присваивание остается на прежнем месте
Strikt mode - переменные не могут быть использованы до их фактического объявлени

ФУНКЦИИ
Function Declaration
Функция конструктор, через new можно создавать обьекты, имеет this\

Function Expression
const func = () => {}
Нет arguments, нет this, обычно используются как колбэки

СТРУКТУРЫ ДАННЫХ:

1. new Map:
   Очень схож с обьектом, отличие в том, есть свои методы, в качестве ключей могут быть любые типы данных
   Есть метод get(ключ), set('ключ', значение), delete(ключ) - возвращает true/false, clear, size

2. new Set:
   Set представляет собой коллекцию уникальных значений, где каждое значение может быть добавлено только один раз. Set также поддерживает методы для добавления, удаления и проверки наличия элементов, а также итерирования по ним. Элементы в Set сохраняются в том порядке, в каком они были добавлены.
   теже методы, + has, values/keys - вернет тоже самое

3. new WeakMap:
   разновидность Map, где ключи объекты, а значения могут быть любыми.
   Один из главных отличий WeakMap от Map заключается в том, что WeakMap не предотвращает удаление ключей из памяти, если они больше не используются в программе.

4. new WeakSet:
   WeakSet является специальной разновидностью Set, где элементы должны быть объектами. Как и в случае с WeakMap, WeakSet не предотвращает удаление элементов из памяти, если они больше не используются.

Хэширование (Hashing)
Это процесс преобразования данных фиксированной длины в хэш-значение фиксированного размера. Хэширование используется для уникальной идентификации данных и быстрого поиска.

stopImmediatePropagation() – для предотвращения вызова других обработчиков
событий на текущем элементе

Что не переживает localStorage? – Очистку кэша

Как можно скопировать/клонировать объект?
● spread - Глубокое копирование происходит только для первого уровня свойств, далее по ссылке
● Object.assign() - аналог spread
● JSON.parse(JSON.stringify(arr)) - копирует глубоко, но без методов, хорош для мал операций
● Object.create(originalObj) - неглубоко, берет существующий объект как прототип, копирует все свойства и методы

this
Грубо говоря, this — это ссылка на объект, к свойствам которого можно получить
доступ внутри вызова функции. this — контекст выполнения.

Методы объектов:
● Object.keys(obj) – возвращает массив строк, представляющих перечисляемые
свойства объекта.
● Object.values(obj) – возвращает массив значений
● Object.entries(obj) – возвращает массив пар [ключ, значение]
● Object.fromEntries(arr) - возвращает обьект из пар [ключ, значение]
● Object.assign(target, ...sources) – копирует значения всех перечисляемых
свойств из одного или нескольких исходных объектов в целевой объект.
● Object.create(proto, [propertiesObject]) – создает новый объект с указанным
прототипом и опциональными дополнительными свойствами.
● obj.hasOwnProperty(prop) – возвращает логическое значение, указывающее присутствует ли ключ

Чем BIND отличается от CALL, APPLY
● Метод bind создает новую функцию, устанавливает указанный контекст
выполнения для этой функции и возвращает эту функцию, не вызывая её.
● Метод call вызывает функцию с указанным контекстом выполнения и принимает аргументы в виде списка.
● Метод apply также вызывает функцию с указанным контекстом выполнения, принимает аргументы в виде массива.

Разница между ASYNC и DEFER у тега SCRIPT?
● async скрипты могут быть выполнены до завершения загрузки
HTML-документа, если несколько то они не мешают друг другу
● defer скрипты будут выполнены только после завершения загрузки
HTML-документа. если несколько то очередь
● Без указания атрибута: Скрипт загружается и выполняется сразу же, блокируя загрузку и рендеринг страницы,
пока он не будет полностью загружен и выполнен.

ИММУТАБЕЛЬНОСТЬ в программировании означает, что данные не могут быть изменены после их создания.
Вместо этого, при необходимости изменить данные, создается новая копия с нужными изменениями.

EVENT LOOP (отвечает за очередь задач) предоставляется средой выполнения (браузер, nodejs)
● call stack (lifo) - (предоставляет движок) небесконечный, можно переполнить
● web API (связывает коллстэк и задачи, это таймауты обработка слушателей/событий )
● очередь задач (предоставляет event loop)
● макротаски - очередь событий (fetch, timer, клик, загрузка изображ, ввод инпут, рендер)
● микротаски - очередь задач (промис, queueMicrotask, mutaionObserver (слежение за дом нодами, какие добавлены/убраны))

ПАТТЕРНЫ
● Singleton (Одиночка): что у класса будет только один экземпляр. Он полезен, когда нужно гарантировать, что объект создается только один раз и глобально доступен.
● Decorator (Декоратор): Этот паттерн позволяет динамически добавлять новую функциональность или поведение к существующему объекту.
● Observer (Наблюдатель): Этот паттерн позволяет объектам следить и реагировать на изменения состояния других объектов.
● Factory (Фабрика): Этот паттерн предоставляет способ создавать экземпляры классов определенного типа.

АНТИПАТТЕРНЫ
● God-Object (классы/модули/компоненты решают сразу всё, в нарушение солид) тут нет высокой связаннности и слабой зацепленности
● Golden Hammer (Золотой молоток): Этот антипаттерн описывает ситуацию, когда разработчики используют один и тот же подход или инструмент в разных ситуациях, даже если это не является самым эффективным или подходящим решением.
● Spaghetti Code (Лапшевый код): Этот антипаттерн описывает код, который сложно понять и поддерживать из-за запутанной логики и неясного потока выполнения.
● Dead Code (Мертвый код): Этот антипаттерн описывает код, который больше не используется в программе, но все еще присутствует в базе кода.

Таблица приведения (Type coercion table)
● нестрогое == и != автоматически перед сравнением
● явное делает разработчик, функции Number(), String() и Boolean()

Лексическое окружение
Функции
Promise

Погружение, захват и всплытие событий – это событийная модель
Погружение идет от самого верхнего элемента в DOM собирая обработчики, и начиная с целевого элемента (захват) начинается всплытие и вызов обработчиков

Полифилл - код || метод || функциональность которая отсутствует в старых версиях браузеров, и мы пишем новый код добавляя метод, к примеру Array.prototype.includes()
