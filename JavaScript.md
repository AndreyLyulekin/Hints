**Docker**
Это платформа, которая позволяет упаковывать и запускать приложения в изолированных контейнерах. Docker упрощает развертывание и масштабирование приложений.

**Rest и Spread**
То есть spread = разворачивает - Раскрывает массив или объект

const arr1 = [1, 2];
const arr2 = [3, 4];
const combined = [...arr1, ...arr2];

а rest = собирает - Собирает остаток аргументов в массив

const user = { id: 1, name: "Andrey", role: "admin" };
const { id, ...rest } = user;
console.log(id);   // 1
console.log(rest); // { name: "Andrey", role: "admin" }


**PROMISE**
Создан что-бы убрать проблему колбэк хэла
Это микротаска, под капотом работающая через microtaskQueue()

Методы:
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

**Деструктуризация**
это когда можно извлекать данные из массивов или обьектов и сразу назначать на переменные

1.  // Деструктуризация массива  
     const numbers = [1, 2, 3, 4, 5];

const [a, b, ...rest] = numbers;

console.log(a); // Вывод: 1
console.log(b); // Вывод: 2
console.log(rest); // Вывод: [3, 4, 5]

2.  // Деструктуризация объекта  
     const person = {
    name: "Alice",
    age: 30,
    city: "New York"
    };

// Деструктуризация объекта с оператором spread
const { name, ...details } = person;

console.log(name); // Вывод: "Alice"
console.log(details); // Вывод: { age: 30, city: "New York" }

**JSON (JavaScript Object Notation)**
Это формат обмена данными, основанный на синтаксисе JavaScript.

var - функциональная область видимости, может быть обьявлена повторно
let, const - появились после ES6 (ES-2015)
let, const - блочная область видимости {}
var, let - могут быть обьявлены до записи значения, и могут быть переопределены
const - не может быть обьявлена до записи значения и соответственно не может быть переопределена, свойства обьектов обьявленных через конст можно изменить
let, const удаляется из памяти после окончательного использования, в отличии от var, становится не инициализированной
Неинициализированная переменная - объявляется с присвоением памяти, но без присвоения значения
При хойстинге, (всплытие в глобальный обьект виндоу, перед выполнением кода) var инициализируется - присваивается значение и тип undefined, let и const остаются неинициализированными
Т.е. у var идёт незначительная нагрузка при построении синтаксического дерева
Нагрузка в том, что при инициализации var, задается значение и тип по умолчанию, затем меняется, когда дело доходит до присвоения значения. Это двойная работа, чего нет у let и const

**Hoisting**
переменные и функции обьявленные через Function Declaration поднимаются в начало области видимости, присваивание остается на прежнем месте
Strikt mode - переменные не могут быть использованы до их фактического объявлени

**ФУНКЦИИ**
Функция высшего порядка, принимает функцию, отдает функцию

Функция первого класса - чистая функция

Function Declaration
Хойстится, Функция конструктор, через new можно создавать обьекты,
имеет this && arguments,
не может быть использована для создания методов обьекта из-за хойстинга (поднимается в начало контекста выполнения, и функция не будет привязана как метод к обьекту)

Function Expression
const greet = function sayHello() {console.log("Привет!");
};
Не хойстится, есть arguments && имеет this, может быть анонимной
может быть использована для создания методов обьекта
после ES6 как метод можно писать без function

Анонимные функции как часть Function Expression
Чаще всего используются как колбэки, или IIFE

Arrow functions ES6
const greet = () => return "Привет!"
Сохраняют контекст this родительской области видимости
Не имеют собственного объекта arguments

**СТРУКТУРЫ ДАННЫХ:**

1. new Map:
   Очень схож с обьектом, отличие в том, есть свои методы, в качестве ключей могут быть любые типы данных
   Есть метод get(ключ), set('ключ', значение), delete(ключ) - возвращает true/false, clear, size

2. new Set:
   Set представляет собой коллекцию уникальных значений, где каждое значение может быть добавлено только один раз. Set также поддерживает методы для добавления, удаления и проверки наличия элементов, а также итерирования по ним. Элементы в Set сохраняются в том порядке, в каком они были добавлены.
   теже методы, + has, values/keys - вернет тоже самое

3. new WeakMap:
   разновидность Map, где ключи объекты, а значения могут быть любыми.
   Один из главных отличий WeakMap от Map заключается в том, что WeakMap не предотвращает удаление ключей из памяти, если они больше не используются в программе.

4. new WeakSet:
   WeakSet является специальной разновидностью Set, где элементы должны быть объектами. Как и в случае с WeakMap, WeakSet не предотвращает удаление элементов из памяти, если они больше не используются.

**Хэширование (Hashing)**
Это когда данные любой размерности преобразуются в хэш-значение фиксированной длинны. 
   Используется для уникальной идентификации данных и быстрого поиска.
при одинаковых данных хэш всегда одинаковый
   из хэша невозможно восстановить исходные данные - Малейшее изменение входа - полностью другой хэш
   У хэш функций как правило очень малая вероятность коллизии
   Посути это “цифровой отпечаток” данных
   Пример пароли на бэкэнде + соль
   Примеры алгоритмов - MD5 (32 символа(128 бит)) слабоват в основном для проверки целостности и SHA-256 (64(256 бит)) для безопасности или SHA-512 + bcrypt лучший для паролей

Что не переживает localStorage? – Очистку кэша

**Как можно скопировать/клонировать объект?**
● spread - Глубокое копирование происходит только для первого уровня свойств, далее по ссылке
● Object.assign() - аналог spread
● JSON.parse(JSON.stringify(arr)) - копирует глубоко, но без методов, хорош для мал операций
● Object.create(originalObj) - неглубоко, берет существующий объект как прототип, копирует все свойства и методы

this
Грубо говоря, this — это ссылка на объект, к свойствам которого можно получить
доступ внутри вызова функции. this — контекст выполнения.

**Чем BIND отличается от CALL, APPLY**
● Метод bind создает новую функцию, устанавливает указанный контекст
выполнения для этой функции и возвращает эту функцию, не вызывая её.
● Метод call вызывает функцию с указанным контекстом выполнения и принимает аргументы в виде списка.
● Метод apply также вызывает функцию с указанным контекстом выполнения, принимает аргументы в виде массива.

**Методы объектов:**
● Object.keys(obj) – возвращает массив строк, представляющих перечисляемые
свойства объекта.
● Object.values(obj) – возвращает массив значений
● Object.entries(obj) – возвращает массив пар [ключ, значение]
● Object.fromEntries(arr) - возвращает обьект из пар [ключ, значение]
● Object.assign(target, ...sources) – копирует значения всех перечисляемых
свойств из одного или нескольких исходных объектов в целевой объект.
● Object.create(proto, [propertiesObject]) – создает новый объект с указанным
прототипом и опциональными дополнительными свойствами.
● obj.hasOwnProperty(prop) – возвращает логическое значение, указывающее присутствует ли ключ

**Разница между ASYNC и DEFER у тега SCRIPT?**
● Когда браузер встречает тег script в HTML без атрибута он приостанавливает парсинг HTML,
загружает app.js, выполняет его, а потом продолжает парсинг дальше, решение:
● async скрипт сразу выполняется, не блокирует парсинг HTML, и будет выполняться даже если парсинг не закончен, 
   если несколько то они не мешают друг другу
      Примеры: Независимые скриптов (например, аналитика, реклама, метрики),
   которые не сильно зависят от DOM или других JS-файлов
● defer скрипты выполнятся только после полного парсинга HTML.
   Порядок выполнения сохраняется (в порядке, как указаны в HTML) 
   Выполняются, когда DOM уже готов (но до CSS/изображений и т.п.)
   если несколько то очередь
      Для скриптов, которые зависят от DOM или других скриптов
      но при этом не должны блокировать загрузку страницы

ИММУТАБЕЛЬНОСТЬ в программировании означает, что данные не могут быть изменены после их создания.
Вместо этого, при необходимости изменить данные, создается новая копия с нужными изменениями.

Абстрактный класс, который не инициализируется(через "new ") используется в качестве прототипа, для наслдования, определяет структуру и методы

**EVENT LOOP** (отвечает за очередь задач) предоставляется средой выполнения (браузер, nodejs)

Эмуляция многопоточности

● call stack (lifo) - структура данных, которую предоставляет JS-движок (например, V8) использует для хранения контекста выполнения функций,
При вызове функции — JS создаёт новый “execution context” (контекст выполнения) и кладёт его на вершину стека. Когда функция завершает работу — её контекст удаляется из вершины
+ небесконечный, можно переполнить - некий :) Stack overflow это если рекурсией замучить колл стек, те постоянно самовызываться и старые функции не будут успевать выйти
● web API это не один модуль а набор асинхронных интерфейсов (коллекция API), предоставляемых именно браузером для движка JS (связывает коллстэк и Task Queue, это таймауты обработка слушателей/событий ) это все апи что есть
● Task Queue очередь задач
● макротаски (FIFO) - очередь событий (fetch или XMLHttp, timer, клик, клава, скролл(i/o), загрузка изображ, рендер) postMessage(между окном и воркером) + Node: setImmediate 
● микротаски (FIFO) - очередь задач (Promise.then/catch/finally, queueMicrotask, mutaionObserver (слежение за дом нодами, какие добавлены/убраны) + async/await)

Event Loop iteration:

1️⃣ Выполняем синхронный код
2️⃣ Выполняем ВСЕ microtasks (FIFO)
3️⃣ Рендер (перерисовка)
4️⃣ Берём следующую macrotask (FIFO)
5️⃣ Снова выполняем ВСЕ microtasks (FIFO)
6️⃣ Повторяем с макро

**API**
Clipboard, Notifications, Geolocation, Web Workers
Observers - MutationObserver, IntersectionObserver, ResizeObserver
Storage API - localStorage, sessionStorage, IndexedDB
Network / HTTP - fetch, XMLHttpRequest, WebSocket, EventSource
Timers API - setTimeout, setInterval, clearTimeout, clearInterval
DOM API - document, addEventListener, querySelector, dispatchEvent
Animation API - requestAnimationFrame, cancelAnimationFrame
Background API - requestIdleCallback

**ПАТТЕРНЫ**
● Singleton (Одиночка): что у класса будет только один экземпляр. Он полезен, когда нужно гарантировать, что объект создается только один раз и глобально доступен.
● Decorator (Декоратор): Этот паттерн позволяет динамически добавлять новую функциональность или поведение к существующему объекту.
● Observer (Наблюдатель): Этот паттерн позволяет объектам следить и реагировать на изменения состояния других объектов.
● Factory (Фабрика): Этот паттерн предоставляет способ создавать экземпляры классов определенного типа.

**АНТИПАТТЕРНЫ**
● God-Object (классы/модули/компоненты решают сразу всё, в нарушение солид) тут нет высокой связаннности и слабой зацепленности
● Golden Hammer (Золотой молоток): Этот антипаттерн описывает ситуацию, когда разработчики используют один и тот же подход или инструмент в разных ситуациях, даже если это не является самым эффективным или подходящим решением.
● Spaghetti Code (Лапшевый код): Этот антипаттерн описывает код, который сложно понять и поддерживать из-за запутанной логики и неясного потока выполнения.
● Dead Code (Мертвый код): Этот антипаттерн описывает код, который больше не используется в программе, но все еще присутствует в базе кода.

**Таблица приведения (Type coercion table)**
console.log(5 == "5"); || true == 1 || null == undefined  // true
console.log(5 === "5");  // false (разные типы)
● нестрогое == и != автоматически перед сравнением
● явное делает разработчик, функции Number(), String() и Boolean()

**Погружение, захват и всплытие событий – это событийная модель**

Три фазы:
Захват — событие идёт сверху вниз по дереву DOM от документа - html - body. И вызвает обработчики если в листенер стоит { capture: true } третьим аргументом
Цель — достижение элемента на котором оно произошло.
Всплытие — событие идёт снизу вверх, от цели к document и вызывает обработчики уже без { capture: true }

e.stopPropagation() - отключает вызов для родительских обработчиков
Пример: Корзина на фоне фото
Антипример: Сломаем подсчет аналитики кликов на этом элементе

e.stopImmediatePropagation() – отключает все остальные обработчики и родительские и другие на этом же элементе
Пример: запретить UI-библиотеке со втроенным обработчиком сделать что-то
+
preventDefault() - отменяем поведение браузера по умолчанию но никак не влияет на всыплытие
Пример отменить презагрузку страницы при сабмите формы





Полифилл - код || метод || функциональность которая отсутствует в старых версиях браузеров, и мы пишем новый код добавляя метод, к примеру Array.prototype.includes()

Лексическое окружение
Promise
ЗАДАЧИ РЕКУРСИЯ
Код сплиттинг
